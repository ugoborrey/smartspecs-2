
# üöÄ Strat√©gie de Normalisation Hybride des Attributs

## Objectif

La strat√©gie hybride vise √† r√©soudre le probl√®me de la maintenance manuelle des tables de mappage d'attributs, tout en garantissant que le processus de canonicalisation reste **rapide**, **d√©terministe** et **coh√©rent** avec la liste officielle des attributs de votre PIM (Product Information Management).

Cette approche utilise un **LLM** pour le travail lent et intelligent de **d√©couverte** et de **proposition de mapping** (une t√¢che de maintenance), et le **SQL** pour l'ex√©cution rapide et fiable du **lookup** (la t√¢che de production).

-----

## I. Sch√©ma des Tables Cl√©s

Nous aurons besoin de deux tables principales pour ce workflow, en plus de `product_documents` et `products_canonical`.

### 1\. Table de R√©f√©rence : `pim_canonical_attributes`

C'est la liste de tous les attributs accept√©s dans votre √©cosyst√®me. Elle est aliment√©e par une synchronisation avec votre PIM.

```sql
CREATE TABLE pim_canonical_attributes (
    -- ID technique
    id SERIAL PRIMARY KEY,

    -- Cl√© du dictionnaire d'attributs (la cl√© de fusion)
    canonical_key TEXT NOT NULL UNIQUE,  -- Ex: 'battery_voltage', 'bore_diameter'

    -- Nom convivial dans une langue de r√©f√©rence (pour le Data Steward)
    canonical_name_fr TEXT,              -- Ex: 'Tension de la batterie'
    canonical_name_en TEXT,              -- Ex: 'Battery Voltage'

    -- Type de donn√©e (pour validation, ex: 'number', 'text', 'unit_of_measure')
    data_type TEXT, 
    
    -- ID ou r√©f√©rence de l'attribut dans le PIM source
    pim_source_reference TEXT
);

-- Index pour une recherche rapide par cl√© de fusion
CREATE UNIQUE INDEX idx_pim_canonical_attributes_key ON pim_canonical_attributes (canonical_key);
```

### 2\. Table de Mappage : `attribute_mappings` (Le Th√©saurus)

C'est la table construite et maintenue par le LLM. Elle mappe les noms trouv√©s dans les PDF bruts vers la cl√© officielle du PIM.

```sql
CREATE TABLE attribute_mappings (
    id SERIAL PRIMARY KEY,

    -- Le nom brut trouv√© dans le document (Source)
    source_name TEXT NOT NULL,       -- Ex: "Voltage batterie", "Diam. Al√©sage"
    
    -- La langue du source_name
    language_code TEXT NOT NULL,     -- Ex: 'fr', 'en'
    
    -- La cl√© officielle PIM vers laquelle ce source_name mappe (Cible)
    canonical_key TEXT NOT NULL REFERENCES pim_canonical_attributes(canonical_key),

    -- Cl√© unique pour √©viter les doublons
    UNIQUE(source_name, language_code)
);

-- Index de lookup pour le processus d'ingestion (CRUCIAL)
CREATE INDEX idx_attribute_mappings_source ON attribute_mappings (source_name, language_code);
```

-----

## II. Workflow 1 : Maintenance du Mapping (LLM-Assist√©e)

Ce script de maintenance est ex√©cut√© en *batch* (ex: une fois par jour ou apr√®s l'ingestion d'un nouveau lot de documents) pour d√©couvrir les nouveaux termes et mettre √† jour la table `attribute_mappings`.

### √âtape A : D√©couverte des Orphelins (SQL)

Le script identifie tous les `source_name` dans `product_documents` qui n'ont pas encore de mapping dans `attribute_mappings`.

**Action SQL** : Utiliser la requ√™te `LEFT JOIN` ou `NOT EXISTS` pour identifier les attributs non mapp√©s.

### √âtape B : Mappage en Batch (LLM)

Le script envoie les termes non mapp√©s (max. 100-200 √† la fois pour rester sous les limites des tokens) au LLM, en lui fournissant la liste officielle du PIM comme contexte.

#### Prompt du LLM

| R√¥le | Contenu |
| :--- | :--- |
| **Syst√®me** | Tu es un expert en normalisation de donn√©es produit. Ta mission est de mapper des noms d'attributs source vers la liste canonique. Ton jugement doit √™tre strict. R√©ponds *uniquement* avec un objet JSON. |
| **Contexte** | **Liste Officielle Canonique PIM :** Fournir la liste `canonical_key` de la table `pim_canonical_attributes`. Ex: `['battery_voltage', 'bore_diameter', 'outside_diameter', ...]` |
| **Utilisateur** | Mappe les attributs source non r√©solus suivants vers une cl√© de la liste canonique fournie. Utilise `null` si aucune correspondance claire n'est trouv√©e. <br><br> Liste √† mapper : `[ { "source_name": "Voltage batterie", "lang": "fr" }, { "source_name": "Diam. Al√©sage", "lang": "fr" }, { "source_name": "Longueur fil", "lang": "fr" } ]` |

### √âtape C : Insertion (SQL)

Le script re√ßoit le JSON du LLM et ins√®re les nouveaux mappings (o√π `canonical_key` est valide) dans la table `attribute_mappings`.

  * **Contr√¥le Humain (Optionnel) :** Les cas mapp√©s sur `null` (ou les 10% des cas les moins s√ªrs selon l'API LLM) peuvent √™tre mis de c√¥t√© pour une revue manuelle par le Data Steward, minimisant ainsi le travail manuel.

-----

## III. Workflow 2 : Canonicalisation (Chemin Rapide SQL)

Lorsqu'un nouveau `ProductDocument` est ing√©r√© et que la fiche `products_canonical` doit √™tre rafra√Æchie, la performance est cruciale.

### Processus

1.  Le script de canonicalisation r√©cup√®re tous les `product_documents` pour un produit.
2.  Pour la phase de fusion des attributs, il ne fait **aucun appel LLM**.
3.  Il utilise une **requ√™te SQL** pour normaliser chaque attribut avant la fusion :

<!-- end list -->

```sql
SELECT
    m.canonical_key AS name,
    attr.value,
    attr.unit
FROM
    product_documents p,
    -- D√©composition des attributs du document brut
    jsonb_to_recordset(p.payload -> 'attributes') AS attr(name TEXT, value TEXT, unit TEXT)
JOIN
    attribute_mappings m ON m.source_name = attr.name AND m.language_code = p.language_code
WHERE
    p.manufacturer_reference = '...'
    AND p.brand = '...'
-- Les attributs pour lesquels aucun mapping n'existe sont ignor√©s (ou mis en quarantaine)
```

### Avantages de l'Ex√©cution (Production)

  * **Vitesse :** L'op√©ration se r√©sume √† une d√©composition JSONB suivie d'un `JOIN` sur des tables index√©es. L'ex√©cution prend des millisecondes.
  * **D√©terminisme :** Le r√©sultat d√©pend uniquement du contenu de la table `attribute_mappings`, qui est une source de v√©rit√© stable.
  * **Co√ªt :** Z√©ro co√ªt d'API LLM en production.

Cette strat√©gie permet de concilier la complexit√© des donn√©es brutes h√©t√©rog√®nes avec le besoin de rigueur et de performance de votre Product Knowledge Hub.